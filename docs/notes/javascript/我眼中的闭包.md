---
prev: false
next: false
---
# 我眼中的闭包

## 闭包的概念

如果一个函数用到了外部的变量，那么这个函数加这个变量叫做闭包。
以前对闭包就是刻板的认识，最近对闭包有了更深一层的理解 。

---

变量的作用域有两种：全局变量跟局部变量
javascript的特殊之处在于函数内部可以直接读取全局函数

```javascript
　var n=999;

　　function f1(){
　　　　alert(n);
　　}

　　f1(); // 999
```

但是函数外部没法读取函数内的局部变量

```javascript
function f1(){
　　　　var n=999;
　　}

　　alert(n); // error
```

如何实现外部读取函数内部的局部变量

```javascript
function f1(){

　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}

　　}
```

在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope）.因为JS 的函数内部可以使用函数外部的变量
既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

```javascript
function f1(){

　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n);
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999
```

代码中的f2函数，就是闭包。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

## 闭包的作用

```javascript
function f1(){

　　　　var n=999;

　　　　nAdd=function(){n+=1}

　　　　function f2(){
　　　　　　alert(n);
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999

　　nAdd();

　　result(); // 1000
```

   在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。
为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。
闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」

## 闭包的缺点

1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
